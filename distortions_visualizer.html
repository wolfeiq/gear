<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial; background: #0a0a0a; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 15px;
      border-radius: 8px;
      max-width: 320px;
      z-index: 100;
      font-size: 13px;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 15px;
      margin: 5px 0;
      cursor: pointer;
      border-radius: 4px;
      width: 100%;
      font-size: 12px;
    }
    button:hover { background: #45a049; }
    #fileInput {
      padding: 5px;
      margin: 10px 0;
      color: white;
      width: 100%;
      font-size: 12px;
    }
    .legend {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #444;
      font-size: 11px;
    }
    .legend-item {
      margin: 5px 0;
      display: flex;
      align-items: center;
    }
    .legend-color {
      width: 15px;
      height: 15px;
      margin-right: 8px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <div id="info">
    <h3 style="margin-top:0">Distortion Network 3D</h3>
    <p style="font-size:12px; margin: 8px 0">
    üñ±Ô∏è Drag to rotate | üîç Scroll to zoom<br>
    üëÜ Click nodes for details</p>
    <div id="nodeInfo"></div>
    <div class="legend">
      <strong>Node Size</strong> = Frequency<br>
      <strong>Edge Thickness</strong> = Co-occurrence<br>
      <strong>Edge Brightness</strong> = Connection strength
    </div>
  </div>
  
  <div id="controls">
    <h4 style="margin-top:0">Controls</h4>
    <input type="file" id="fileInput" accept=".json">
    <button onclick="resetCamera()">Reset View</button>
    <button onclick="toggleLabels()">Toggle Labels</button>
    <button onclick="toggleClusters()">Show Clusters</button>
    <div id="stats" style="margin-top:10px; font-size:11px; color:#aaa;"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let nodes = [], edges = [], labels = [];
    let showLabels = true;
    let showClusters = false;
    let graphData;

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 50, 150);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 60;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x404040, 2);
      scene.add(ambientLight);
      
      const pointLight = new THREE.PointLight(0xffffff, 1.5);
      pointLight.position.set(50, 50, 50);
      scene.add(pointLight);

      const pointLight2 = new THREE.PointLight(0x4444ff, 0.5);
      pointLight2.position.set(-50, -50, 50);
      scene.add(pointLight2);

      setupControls();
      document.getElementById('fileInput').addEventListener('change', handleFileSelect);
      animate();
    }

    function setupControls() {
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };

      renderer.domElement.addEventListener('mousedown', () => isDragging = true);
      renderer.domElement.addEventListener('mouseup', () => isDragging = false);
      
      renderer.domElement.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;
          scene.rotation.y += deltaX * 0.005;
          scene.rotation.x += deltaY * 0.005;
        }
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      renderer.domElement.addEventListener('wheel', (e) => {
        e.preventDefault();
        camera.position.z += e.deltaY * 0.08;
        camera.position.z = Math.max(15, Math.min(200, camera.position.z));
      });

      renderer.domElement.addEventListener('click', onNodeClick);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          graphData = JSON.parse(e.target.result);
          loadGlobalGraph();
          document.getElementById('stats').innerHTML = 
            `‚úì ${Object.keys(graphData.personal_graphs).length} users loaded<br>
             ‚úì ${graphData.global_graph.nodes.length} distortion types<br>
             ‚úì ${graphData.global_graph.edges.length} connections`;
        } catch (err) {
          alert('Error: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    function loadGlobalGraph() {
      clearScene();
      const nodeWeights = {};
      graphData.global_graph.edges.forEach(edge => {
        nodeWeights[edge.source] = (nodeWeights[edge.source] || 0) + edge.weight;
        nodeWeights[edge.target] = (nodeWeights[edge.target] || 0) + edge.weight;
      });

      const graphNodes = graphData.global_graph.nodes.map(id => ({
        id,
        weight: nodeWeights[id] || 1,
        degree: graphData.global_graph.edges.filter(e => 
          e.source === id || e.target === id
        ).length
      }));

      const graphEdges = graphData.global_graph.edges;

      createGraph(graphNodes, graphEdges);
    }

    function createGraph(graphNodes, graphEdges) {
      const radius = 40;
      const maxWeight = Math.max(...graphNodes.map(n => n.weight));
      
      const sorted = [...graphNodes].sort((a, b) => b.weight - a.weight);
      const clusters = {
        core: sorted.slice(0, 8),     
        major: sorted.slice(8, 16),    
        minor: sorted.slice(16)        
      };

      graphNodes.forEach((node, i) => {
        let clusterRadius = radius;
        if (clusters.core.includes(node)) clusterRadius = radius * 0.6;
        else if (clusters.major.includes(node)) clusterRadius = radius * 0.9;
        
        const phi = Math.acos(-1 + (2 * i) / graphNodes.length);
        const theta = Math.sqrt(graphNodes.length * Math.PI) * phi;
        
        const x = clusterRadius * Math.cos(theta) * Math.sin(phi);
        const y = clusterRadius * Math.sin(theta) * Math.sin(phi);
        const z = clusterRadius * Math.cos(phi);

        const sizeScale = node.weight / maxWeight;
        const size = 0.8 + (sizeScale * 3);
        
        const geometry = new THREE.SphereGeometry(size, 32, 32);
        const material = new THREE.MeshPhongMaterial({ 
          color: getNodeColor(node),
          emissive: getNodeColor(node),
          emissiveIntensity: 0.3 + (sizeScale * 0.4),
          shininess: 60,
          specular: 0x444444
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(x, y, z);
        sphere.userData = node;
        scene.add(sphere);
        nodes.push(sphere);

        if (clusters.core.includes(node)) {
          const glowGeometry = new THREE.SphereGeometry(size * 1.3, 32, 32);
          const glowMaterial = new THREE.MeshBasicMaterial({
            color: getNodeColor(node),
            transparent: true,
            opacity: 0.2
          });
          const glow = new THREE.Mesh(glowGeometry, glowMaterial);
          glow.position.set(x, y, z);
          scene.add(glow);
        }

        if (showLabels) {
          createLabel(node, x, y + size + 2, z, sizeScale);
        }
      });

      const maxEdgeWeight = Math.max(...graphEdges.map(e => e.weight));
      
      graphEdges.forEach(edge => {
        const sourceNode = nodes.find(n => n.userData.id === edge.source);
        const targetNode = nodes.find(n => n.userData.id === edge.target);
        
        if (sourceNode && targetNode) {
          const weightRatio = edge.weight / maxEdgeWeight;
          
          if (weightRatio < 0.05) return;
          
          const points = [sourceNode.position, targetNode.position];
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          
          const opacity = 0.2 + (weightRatio * 0.6);
          const color = new THREE.Color().setHSL(0.55, 1, 0.3 + (weightRatio * 0.4));
          
          const material = new THREE.LineBasicMaterial({ 
            color: color,
            transparent: true,
            opacity: opacity,
            linewidth: 1 + (weightRatio * 3)
          });
          
          const line = new THREE.Line(geometry, material);
          line.userData = { weight: edge.weight };
          scene.add(line);
          edges.push(line);

          // Add arrow
          const direction = new THREE.Vector3().subVectors(targetNode.position, sourceNode.position);
          const arrowPos = new THREE.Vector3().addVectors(
            sourceNode.position, 
            direction.multiplyScalar(0.7)
          );
          
          const arrowGeometry = new THREE.ConeGeometry(0.3 + weightRatio, 0.8 + weightRatio, 8);
          const arrowMaterial = new THREE.MeshBasicMaterial({ 
            color: color,
            transparent: true,
            opacity: opacity
          });
          const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
          arrow.position.copy(arrowPos);
          arrow.lookAt(targetNode.position);
          arrow.rotateX(Math.PI / 2);
          scene.add(arrow);
          edges.push(arrow);
        }
      });
    }

    function createLabel(node, x, y, z, importance) {
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 512;
      canvas.height = 128;
      
      const fontSize = 35 + (importance * 20);
      context.fillStyle = 'white';
      context.font = `bold ${fontSize}px Arial`;
      context.shadowColor = 'black';
      context.shadowBlur = 8;
      
      const text = node.id.replace(/_/g, ' ').slice(0, 25);
      context.fillText(text, 10, 70);
      
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ 
        map: texture,
        transparent: true
      });
      const sprite = new THREE.Sprite(spriteMaterial);
      const scale = 8 + (importance * 4);
      sprite.scale.set(scale, scale * 0.25, 1);
      sprite.position.set(x, y, z);
      scene.add(sprite);
      labels.push(sprite);
    }

    function getNodeColor(node) {
      const colors = {
        'catastrophizing': 0xff2244,
        'all_or_nothing_thinking': 0xff8800,
        'all_or_nothing': 0xff8800,
        'overgeneralization': 0xffcc00,
        'mind_reading': 0x22ff44,
        'fortune_telling': 0x2244ff,
        'labeling': 0xff22ff,
        'emotional_reasoning': 0xff88ff,
        'personalization': 0x22ffff,
        'mental_filter': 0xff4488,
        'should_statements': 0x8844ff,
        'hopelessness': 0x444444,
        'jumping_to_conclusions': 0x44ff88
      };
      return colors[node.id] || 0x888888;
    }

    function clearScene() {
      [...nodes, ...edges, ...labels].forEach(obj => scene.remove(obj));
      nodes = [];
      edges = [];
      labels = [];
    }

    function onNodeClick(event) {
      const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
      );

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      
      const intersects = raycaster.intersectObjects(nodes);
      
      if (intersects.length > 0) {
        const node = intersects[0].object.userData;
        const name = node.id.replace(/_/g, ' ');
        const connectedEdges = edges.filter(e => 
          e.geometry.attributes.position.array
        ).length;
        
        document.getElementById('nodeInfo').innerHTML = `
          <hr style="border-color:#444">
          <strong style="font-size:14px">${name}</strong><br>
          Total weight: ${node.weight.toFixed(0)}<br>
          Connections: ${node.degree}<br>
          <em style="color:#aaa; font-size:11px">
          ${node.weight > 500 ? 'Core hub node' : 
            node.weight > 200 ? 'Major distortion' : 
            'Supporting pattern'}
          </em>
        `;
      }
    }

    function resetCamera() {
      camera.position.set(0, 0, 60);
      scene.rotation.set(0, 0, 0);
    }

    function toggleLabels() {
      showLabels = !showLabels;
      if (graphData) loadGlobalGraph();
    }

    function toggleClusters() {
      showClusters = !showClusters;

      alert('Clusters visible by node positioning (core = inner, minor = outer)');
    }

    function animate() {
      requestAnimationFrame(animate);
      scene.rotation.y += 0.001;
      
      nodes.forEach((node, i) => {
        if (node.userData.weight > 400) {
          const pulse = Math.sin(Date.now() * 0.001 + i) * 0.1;
          node.scale.set(1 + pulse, 1 + pulse, 1 + pulse);
        }
      });
      
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>